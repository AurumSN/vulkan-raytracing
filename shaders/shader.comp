#version 450

#define USE_SPHERE_TRACING
// #define USE_ANALYTIC
// #define USE_NEWTOWNS

const float epsilon = 0.00000001;
const uint maxHitCount = 5;
const float pi = 3.1415926535897932384626433832795;

layout (binding = 0) uniform ParameterUBO {
    ivec2 screenSize;
    mat4 view;
    mat4 proj;
} ubo;

layout (binding = 1, rgba8) uniform writeonly image2D outputImage;

struct Material {
    vec4 color;
    float reflective;
    float refractiv; // not used
};

struct Primitive {
    vec4 data;
    uint type;
    Material material;
};

layout (std430, binding = 2) readonly buffer PrimitivesSSBO {
    uint primitiveCount;
    Primitive primitives[ ];
};

layout (std430, binding = 3) readonly buffer VertexSSBO {
    vec4 vertices[ ];
};

layout (std430, binding = 4) readonly buffer IndexSSBO {
    uint indices[ ];
};

struct Mesh {
    uint begin;
    Material material;
};

layout (std430, binding = 5) readonly buffer MeshSSBO {
    uint meshCount;
    Mesh meshes[ ];
};

layout (std430, binding = 6) readonly buffer TriangleSSBO {
    uint triangles[ ];
};

struct BVH {
    uint index;
    uint escape;
    uint left;
    uint right;
    vec4 AABBmin;
    vec4 AABBmax;
};

layout (std430, binding = 7) readonly buffer BVHSSBO {
    BVH bvhs[ ];
};

struct Light {
    vec4 position;
    vec4 color;
};

layout (std430, binding = 8) readonly buffer LightSSBO {
    uint lightCount;
    Light lights[ ];
};

layout (std430, binding = 9) readonly buffer GridDistancesSSBO {
    float SDFGrid[ ];
};

struct Grid {
    uint index;
    uvec3 size;
    Material material;
    mat4 inverseMatrix;
};

layout (std430, binding = 10) readonly buffer GridSSBO {
    uint gridCount;
    Grid grids[ ];
};

struct OctreeNode {
    float values[8];
    uint offset;
    uint escape;
    vec4 boxMin;
    vec4 boxMax;
};

layout (std430, binding = 11) readonly buffer OctreeNodesSSBO {
    OctreeNode octreeNodes[ ];
};

struct Octree {
    uint index;
    uint size;
    Material material;
    mat4 inverseMatrix;
};

layout (std430, binding = 12) readonly buffer OctreesSSBO {
    uint octreeCount;
    Octree octrees[ ];
};

struct Ray {
    vec4 origin;
    vec4 direction;
};

struct Hit {
    float t;
    vec4 point;
    vec4 normal;
    vec2 uv;
    Material material;
    bool receivesShadows;
};

Hit noHit() {
    Hit h;
    h.t = -1.0;
    return h;
}

Hit isHit(float t, Ray ray, vec4 normal, vec2 uv, Material material, bool receivesShadows) {
    Hit h;
    h.t = t;
    h.point = ray.origin + ray.direction * t * 0.9999;
    h.normal = normal,
    h.uv = uv;
    h.material = material;
    h.receivesShadows = receivesShadows;
    return h;
}

float hitAABB(vec4 AABBmin, vec4 AABBmax, Ray ray) {
    const int NUMDIM = 3;
    int RIGHT = 0;
    int LEFT = 1;
    int MIDDLE = 2;

    bool inside = true;
    int quadrant[NUMDIM];
    float candidatePlane[NUMDIM];

    vec4 _min = min(AABBmin, AABBmax);
    vec4 _max = max(AABBmin, AABBmax);
    
    for (int i = 0; i < NUMDIM; i++) {
        if (ray.origin[i] < _min[i]) {
            quadrant[i] = LEFT;
            candidatePlane[i] = _min[i];
            inside = false;
        } else if (ray.origin[i] > _max[i]) {
            quadrant[i] = RIGHT;
            candidatePlane[i] = _max[i];
            inside = false;
        } else {
            quadrant[i] = MIDDLE;
        }
    }

    if (inside) {
        return epsilon * 2;
    }
    
    vec4 maxT;

    for (int i = 0; i < NUMDIM; i++) {
        if (quadrant[i] != MIDDLE && abs(ray.direction[i]) >= epsilon) {
            maxT[i] = (candidatePlane[i] - ray.origin[i]) / ray.direction[i];
        } else {
            maxT[i] = -1.0f;
        }
    }

    int whichPlane = 0;

    for (int i = 1; i < NUMDIM; i++) {
        if (maxT[whichPlane] < maxT[i]) {
            whichPlane = i;
        }
    }

    if (maxT[whichPlane] <= 0.0) {
        return -1.0;
    }

    for (int i = 0; i < NUMDIM; i++) {
        if (whichPlane != i) {
            float coord = ray.origin[i] + maxT[whichPlane] * ray.direction[i];
            if (coord < _min[i] || coord > _max[i]) {
                return -1.0;
            }
        }
    }

    return maxT[whichPlane];
}

Hit hitPlane(vec4 plane, Ray ray, Material material) {
    float tmp = dot(plane, ray.direction);

    if (abs(tmp) < epsilon) {
        return noHit();
    }

    float t = -dot(plane, ray.origin) / tmp;

    if (t > epsilon) {
        vec4 normal = normalize(vec4(plane.xyz, 0.0));

        if (dot(normal, ray.direction) > epsilon) {
            // return noHit();
            normal = -normal;
        }

        return isHit(t, ray, normal, vec2(0.0, 0.0), material, true);
    }

    return noHit();
}

Hit hitSphere(vec4 sphere, Ray ray, Material material) {
    vec4 l = vec4(sphere.xyz, 1.0) - ray.origin;
    float tca = dot(l, normalize(ray.direction));
    if (tca <= epsilon) {
        return noHit();
    }
    float d2 = dot(l, l) - tca * tca;
    if (d2 > sphere.w * sphere.w) {
        return noHit();
    }
    float thc = sqrt(sphere.w * sphere.w - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = t1;
    }

    if (t0 <= epsilon) {
        t0 = t1;
        if (t0 <= epsilon) {
            return noHit();
        }
    }

    t0 = t0 / length(ray.direction);

    vec4 normal = normalize(ray.origin + ray.direction * t0 - vec4(sphere.xyz, 1.0));

    return isHit(t0, ray, normal, vec2(0.0, 0.0), material, true);
}

Hit hitCube(vec4 cube, Ray ray, Material material) {
    vec4 _min = vec4(cube.xyz, 0.0) - cube.w;
    vec4 _max = vec4(cube.xyz, 0.0) + cube.w;
    float t = hitAABB(_min, _max, ray);
    vec4 p = ray.origin + t * ray.direction;
    vec4 d = p - vec4(cube.xyz, 1.0);
    if (abs(d.x) > abs(d.y)) {
        if (abs(d.x) > abs(d.z)) {
            if (d.x > 0.0) {
                return isHit(t, ray, vec4(1.0, 0.0, 0.0, 0.0), vec2(0.0, 0.0), material, true);
            } else {
                return isHit(t, ray, vec4(-1.0, 0.0, 0.0, 0.0), vec2(0.0, 0.0), material, true);
            }
        } else {
            if (d.z > 0.0) {
                return isHit(t, ray, vec4(0.0, 0.0, 1.0, 0.0), vec2(0.0, 0.0), material, true);
            } else {
                return isHit(t, ray, vec4(0.0, 0.0, -1.0, 0.0), vec2(0.0, 0.0), material, true);
            }
        }
    } else {
        if (abs(d.y) > abs(d.z)) {
            if (d.y > 0.0) {
                return isHit(t, ray, vec4(0.0, 1.0, 0.0, 0.0), vec2(0.0, 0.0), material, true);
            } else {
                return isHit(t, ray, vec4(0.0, -1.0, 0.0, 0.0), vec2(0.0, 0.0), material, true);
            }
        } else {
            if (d.z > 0.0) {
                return isHit(t, ray, vec4(0.0, 0.0, 1.0, 0.0), vec2(0.0, 0.0), material, true);
            } else {
                return isHit(t, ray, vec4(0.0, 0.0, -1.0, 0.0), vec2(0.0, 0.0), material, true);
            }
        }
    }
}

Hit hitPolygon(uint triangle, Ray ray, Material material) {
    vec4 p1 = vertices[indices[triangle + 0]];
    vec4 p2 = vertices[indices[triangle + 1]];
    vec4 p3 = vertices[indices[triangle + 2]];

    vec4 e1 = p2 - p1;
    vec4 e2 = p3 - p1;
    vec4 crs = vec4(cross(ray.direction.xyz, e2.xyz), 0.0);

    float det = dot(e1, crs);

    if (abs(det) < epsilon) {
        return noHit();
    }

    float inv_det = 1.0 / det;
    vec4 s = ray.origin - p1;
    float u = inv_det * dot(s, crs);

    if ((u < -epsilon) || (u - 1.0 > epsilon)) {
        return noHit();
    }

    vec4 scrse1 = vec4(cross(s.xyz, e1.xyz), 0.0);
    float v = inv_det * dot(ray.direction, scrse1);

    if ((v < -epsilon) || (u + v - 1.0 > epsilon)) {
        return noHit();
    }

    float t = inv_det * dot(e2, scrse1);

    if (t > epsilon) {
        vec4 normal = normalize(vec4(cross(e1.xyz, e2.xyz), 0.0));
        if (dot(normal, ray.direction) > epsilon) {
            return noHit();
            // normal = -normal;
        }
        return isHit(t, ray, normal, vec2(u, v), material, true);
    }

    return noHit();
}

Ray screenToRay() {
    vec2 sc = 2.0 * (vec2(gl_GlobalInvocationID.xy) - vec2(0.5, 0.5)) / vec2(ubo.screenSize.xy) - 1.0;
    sc = -sc;

    vec4 pos = ubo.view * ubo.proj * vec4(sc, 0.0, 1.0);
    pos /= pos.w;

    pos = normalize(pos - ubo.view * vec4(0.0, 0.0, 0.0, 1.0));

    Ray r;
    r.origin = ubo.view * vec4(0.0, 0.0, 0.0, 1.0);
    r.direction = pos;

    return r;
}

Hit hitMesh(uint mesh, Ray ray) {
    Hit h = noHit();

    uint i = meshes[mesh].begin + 1;

    while (i != 0) {
        float tmin = hitAABB(bvhs[i - 1].AABBmin, bvhs[i - 1].AABBmax, ray);
        if (tmin > epsilon && (h.t <= epsilon || h.t > tmin)) {
            if (bvhs[i - 1].left == 0) {
                for (uint j = bvhs[i - 1].index; j < bvhs[i].index; j++) {
                    Hit tmp = hitPolygon(triangles[j], ray, meshes[mesh].material);

                    if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
                        h = tmp;
                    }
                }

                i = bvhs[i - 1].escape;
            } else {
                i = bvhs[i - 1].left;
            }
        } else {
            i = bvhs[i - 1].escape;
        }
    }

    return h;
}

bool insideBox(vec4 p, vec4 a, vec4 b) {
    vec4 _min = min(a, b);
    vec4 _max = max(a, b);
    for (uint i = 0; i < 3; i++) {
        if (p[i] < _min[i] || p[i] > _max[i]) {
            return false;
        }
    }
    return true;
}

float getNodeDistance(vec4 position, vec4 boxMin, vec4 boxMax, float values[8]) {
    float dist = 0.0;

    for (uint i = 0; i < 8; i++) {
        vec3 pos = vec3(i % 2, (i >> 1) % 2, i >> 2);
        vec3 delta = 1.0 - pos + (position - boxMin).xyz / (boxMax - boxMin).xyz * (2 * pos - 1.0);
        dist += values[i] * delta.x * delta.y * delta.z;
    }

    return dist;
}

vec4 getNodeNormal(vec4 position, vec4 boxMin, vec4 boxMax, float values[8]) {
    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);

    for (uint i = 0; i < 8; i++) {
        uvec3 off = uvec3(i % 2, (i >> 1) % 2, i >> 2);
        vec3 delta = 1.0 - vec3(off) + (position - boxMin).xyz / (boxMax - boxMin).xyz * (2 * vec3(off) - 1.0);
        for (uint j = 0; j < 3; j++) {
            if (off[j] == 0) {
                normal[j] -= values[i] * delta[(j + 1) % 3] * delta[(j + 2) % 3];
            } else {
                normal[j] += values[i] * delta[(j + 1) % 3] * delta[(j + 2) % 3];
            }
        }
    }

    return normal;
}

float getGridDistance(vec4 position, Grid grid) {
    uvec3 pos = uvec3(vec3(position + 1.0) * 0.5 * vec3(grid.size - 1));

    float dist = 0.0;

    for (uint i = 0; i < 8; i++) {
        uvec3 vert = pos + uvec3(i % 2, (i >> 1) % 2, i >> 2);
        uint index = vert.x + vert.y * grid.size.x + vert.z * grid.size.x * grid.size.y;
        vec3 delta = 1.0 - abs(vec3(position + 1.0) * 0.5 * vec3(grid.size - 1) - vec3(vert));
        dist += SDFGrid[grid.index + index] * delta.x * delta.y * delta.z;
    }

    return dist;
}

vec4 getGridNormal(vec4 position, Grid grid) {
    uvec3 pos = uvec3(vec3(position + 1.0) * 0.5 * vec3(grid.size - 1));

    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);

    for (uint i = 0; i < 8; i++) {
        uvec3 off = uvec3(i % 2, (i >> 1) % 2, i >> 2);
        uvec3 vert = pos + off;
        uint index = vert.x + vert.y * grid.size.x + vert.z * grid.size.x * grid.size.y;
        vec3 delta = 1.0 - abs(vec3(position + 1.0) * 0.5 * vec3(grid.size - 1) - vec3(vert));
        for (uint j = 0; j < 3; j++) {
            if (off[j] == 0) {
                normal[j] -= SDFGrid[grid.index + index] * delta[(j + 1) % 3] * delta[(j + 2) % 3];
            } else {
                normal[j] += SDFGrid[grid.index + index] * delta[(j + 1) % 3] * delta[(j + 2) % 3];
            }
        }
    }

    return normal;
}

Hit hitGrid(uint grid, Ray ray) {
    const float minDist = 0.001;
    const float maxDist = 1000.0;

    Ray r;
    r.origin = grids[grid].inverseMatrix * ray.origin;
    r.direction = grids[grid].inverseMatrix * ray.direction;
    
    float t = hitAABB(vec4(-1.0, -1.0, -1.0, 0.0), vec4(1.0, 1.0, 1.0, 0.0), r);
    if (t < 0.0) {
        return noHit();
    }

    vec4 position = clamp(r.origin + r.direction * t, vec4(-1.0, -1.0, -1.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0));
    vec4 direction = normalize(r.direction);
    float overlen = 1.0 / length(r.direction);

    float d = getGridDistance(position, grids[grid]);
    t += d * overlen;
    uint count = 0;
    while (abs(d) > minDist && abs(d) < maxDist && count < 1000 && insideBox(position, vec4(-1.0, -1.0, -1.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0))) {
        position += direction * d;
        d = getGridDistance(position, grids[grid]);
        t += d * overlen;
        count++;
    }

    if (abs(d) > maxDist || count >= 1000 || !insideBox(position, vec4(-1.0, -1.0, -1.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0))) {
        return noHit();
    }

    return isHit(t, ray, normalize(inverse(grids[grid].inverseMatrix) * getGridNormal(position, grids[grid])), vec2(0.0, 0.0), grids[grid].material, false);
}

float evalCubic(float t, float a, float b, float c, float d) {
    return a * t * t * t + b * t * t + c * t + d;
}

float evalQuadratic(float t, float a, float b, float c) {
    return a * t * t + b * t + c;
}

float solveMinCubicInRange(float a, float b, float c, float d, float minR) {
    if (abs(a) < epsilon) {
        a = b;
        b = c;
        c = d;
        if (abs(a) < epsilon) {
            a = b;
            b = c;
            if (abs(a) < epsilon) {
                return minR;
            }
            return -b/a;
        }

        float D = b * b - 4 * a * c;

        if (abs(D) < epsilon) {
            return -b / (2 * a);
        } else if (D > 0.0) {
            float x1 = (-b - sqrt(D)) / (2 * a);
            float x2 = (-b + sqrt(D)) / (2 * a);

            if (x1 > x2) {
                float tmp = x1;
                x1 = x2;
                x2 = tmp;
            }

            if (x1 >= minR) {
                return x1;
            }

            return x2;
        }
        return minR - 1;
    }

    float p = (3*a*c - b*b)/(3*a*a);
    float q = (2*b*b*b - 9*a*b*c + 27*a*a*d)/(27*a*a*a);

    if (abs(p) < epsilon) {
        if (q >= 0.0) {
            return -pow(q, 1.0 / 3.0) - b / (3 * a);
        } else {
            return pow(-q, 1.0 / 3.0) - b / (3 * a);
        }
    } else if (abs(q) < epsilon) {
        if (p < 0.0) {
            float x = sqrt(-p);

            if (-x - b / (3 * a) >= minR) {
                return -x - b / (3 * a);
            } else if (-b / (3 * a) >= minR) {
                return -b / (3 * a);
            }

            return x - b / (3 * a);
        }
        return -b / (3 * a);
    } else {
        float D = q * q / 4.0 + p * p * p / 27.0;
        if (abs(D) < epsilon) {
            float x1 = -1.5 * q / p - b / (3.0 * a);
            float x2 = 3.0 * q / p - b / (3.0 * a);

            if (x1 > x2) {
                float tmp = x1;
                x1 = x2;
                x2 = tmp;
            }
            if (x1 >= minR) {
                return x1;
            }
            return x2;
        } else if (D > 0.0) {
            float u;
            if (-q * 0.5 - sqrt(D) < 0.0) {
                u = -pow(q * 0.5 + sqrt(D), 1.0 / 3.0);
            } else {
                u = pow(-q * 0.5 - sqrt(D), 1.0 / 3.0);
            }

            return u - p / (3.0 * u) - b / (3.0 * a);
        } else {
            float u = 2.0 * sqrt(-p / 3.0);
            float t = acos(3.0 * q / p / u) / 3.0;
            float k = 2.0 * pi / 3.0;
            float x1 = u * cos(t) - b / (3.0 * a);
            float x2 = u * cos(t - k) - b / (3.0 * a);
            float x3 = u * cos(t - 2 * k) - b / (3.0 * a);

            if (x1 > x2) {
                float tmp = x1;
                x1 = x2;
                x2 = tmp;
            }
            if (x2 > x3) {
                float tmp = x2;
                x2 = x3;
                x3 = tmp;
            }
            if (x1 > x2) {
                float tmp = x1;
                x1 = x2;
                x2 = tmp;
            }
            if (x1 >= minR) {
                return x1;
            }
            if (x2 >= minR) {
                return x2;
            }
            return x3;
        }
    }
}

Hit hitOctree(uint octree, Ray ray) {
    const float minDist = 0.001;
    const float maxDist = 1000.0;

    Ray r;
    r.origin = octrees[octree].inverseMatrix * ray.origin;
    r.direction = octrees[octree].inverseMatrix * ray.direction;

    uint offset = 0;
    uint index = octrees[octree].index;

    float minT = -1.0;
    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);

    float t = hitAABB(octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, r);

    if (t >= 0.0) {
        offset = octreeNodes[index + offset].offset;
        while (offset != 0) {
            t = hitAABB(octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, r);
            if (t >= 0.0 && (minT < 0.0 || t < minT)) {
                if (octreeNodes[index + offset].offset == 0) {
                    bool a = false;

                    for (uint i = 0; i < 8; i++) {
                        if (octreeNodes[index + offset].values[i] != 0.0 && octreeNodes[index + offset].values[i] < 10.0) {
                            a = true;
                            break;
                        }
                    }

                    if (a) {
#ifdef USE_ANALYTIC
                        vec3 o = (r.origin - octreeNodes[index + offset].boxMin).xyz / (octreeNodes[index + offset].boxMax - octreeNodes[index + offset].boxMin).xyz;
                        vec3 d = r.direction.xyz / (octreeNodes[index + offset].boxMax - octreeNodes[index + offset].boxMin).xyz;

                        float ca = octreeNodes[index + offset].values[5] - octreeNodes[index + offset].values[4];
                        float k0 = octreeNodes[index + offset].values[0];
                        float k1 = octreeNodes[index + offset].values[1] - k0;
                        float k2 = octreeNodes[index + offset].values[2] - k0;
                        float k3 = octreeNodes[index + offset].values[3] - octreeNodes[index + offset].values[2] - k1;
                        float k4 = k0 - octreeNodes[index + offset].values[4];
                        float k5 = k1 - ca;
                        float k6 = k2 - (octreeNodes[index + offset].values[6] - octreeNodes[index + offset].values[4]);
                        float k7 = k3 - (octreeNodes[index + offset].values[7] - octreeNodes[index + offset].values[6] - ca);

                        float m0 = o.x * o.y;
                        float m1 = d.x * d.y;
                        float m2 = o.x * d.y + o.y * d.x;
                        float m3 = k5 * o.z - k1;
                        float m4 = k6 * o.z - k2;
                        float m5 = k7 * o.z - k3;

                        float pd = (k4 * o.z - k0) + o.x * m3 + o.y * m4 + m0 * m5;
                        float pc = d.x * m3 + d.y * m4 + m2 * m5 + d.z * (k4 + k5 * o.x + k6 * o.y + k7 * m0);
                        float pb = m1 * m5 + d.z * (k5 * d.x + k6 * d.y + k7 * m2);
                        float pa = k7 * m1 * d.z;

                        float tc = solveMinCubicInRange(pa, pb, pc, pd, t);
                        if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                            minT = tc;
                            normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                        }
#else
#ifdef USE_NEWTOWNS
                        vec3 o = (r.origin - octreeNodes[index + offset].boxMin).xyz / (octreeNodes[index + offset].boxMax - octreeNodes[index + offset].boxMin).xyz;
                        vec3 d = r.direction.xyz / (octreeNodes[index + offset].boxMax - octreeNodes[index + offset].boxMin).xyz;

                        float ca = octreeNodes[index + offset].values[5] - octreeNodes[index + offset].values[4];
                        float k0 = octreeNodes[index + offset].values[0];
                        float k1 = octreeNodes[index + offset].values[1] - k0;
                        float k2 = octreeNodes[index + offset].values[2] - k0;
                        float k3 = octreeNodes[index + offset].values[3] - octreeNodes[index + offset].values[2] - k1;
                        float k4 = k0 - octreeNodes[index + offset].values[4];
                        float k5 = k1 - ca;
                        float k6 = k2 - (octreeNodes[index + offset].values[6] - octreeNodes[index + offset].values[4]);
                        float k7 = k3 - (octreeNodes[index + offset].values[7] - octreeNodes[index + offset].values[6] - ca);

                        float m0 = o.x * o.y;
                        float m1 = d.x * d.y;
                        float m2 = o.x * d.y + o.y * d.x;
                        float m3 = k5 * o.z - k1;
                        float m4 = k6 * o.z - k2;
                        float m5 = k7 * o.z - k3;

                        float pd = (k4 * o.z - k0) + o.x * m3 + o.y * m4 + m0 * m5;
                        float pc = d.x * m3 + d.y * m4 + m2 * m5 + d.z * (k4 + k5 * o.x + k6 * o.y + k7 * m0);
                        float pb = m1 * m5 + d.z * (k5 * d.x + k6 * d.y + k7 * m2);
                        float pa = k7 * m1 * d.z;

                        float qa = 3 * pa;
                        float qb = 2 * pb;
                        float qc = pc;

                        float D = qb * qb - 4 * qa * qc;
                        if (abs(pa) <= epsilon) {
                            if (abs(pb) <= epsilon) {
                                float tc = -pd / pc;
                                if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                    minT = tc;
                                    normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                }
                            } else {
                                float x = -qc / qb;

                                if (x >= t && abs(evalCubic(x, pa, pb, pc, pd)) <= epsilon) {
                                    float tc = x;
                                    if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                        minT = tc;
                                        normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                    }
                                }

                                if (x >= t && evalCubic(x, pa, pb, pc, pd) * evalCubic(t - 4.0, pa, pb, pc, pd) <= 0.0) {
                                    float tc = (evalCubic(x, pa, pb, pc, pd) * (t - 4.0) - evalCubic(t - 4.0, pa, pb, pc, pd) * x) / (evalCubic(x, pa, pb, pc, pd) - evalCubic(t - 4.0, pa, pb, pc, pd));
                                    float tp = -1000.0;

                                    for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                        float gt = evalCubic(tc, pa, pb, pc, pd);
                                        float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                        tp = tc;
                                        tc -= gt / gt_deriv;
                                    }

                                    if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                        minT = tc;
                                        normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                    }
                                }

                                if (x <= t + 4.0 && evalCubic(x, pa, pb, pc, pd) * evalCubic(t + 4.0, pa, pb, pc, pd) <= 0.0) {
                                    float tc = (evalCubic(x, pa, pb, pc, pd) * (t + 4.0) - evalCubic(t + 4.0, pa, pb, pc, pd) * x) / (evalCubic(x, pa, pb, pc, pd) - evalCubic(t + 4.0, pa, pb, pc, pd));
                                    float tp = -1000.0;

                                    for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                        float gt = evalCubic(tc, pa, pb, pc, pd);
                                        float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                        tp = tc;
                                        tc -= gt / gt_deriv;
                                    }

                                    if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                        minT = tc;
                                        normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                    }
                                }
                            }
                        } else if (D >= 0.0) {
                            float x1 = (-qb - sqrt(D)) * 0.5 / qa;
                            float x2 = (-qb + sqrt(D)) * 0.5 / qa;

                            if (x1 > x2) {
                                float tmp = x2;
                                x2 = x1;
                                x1 = tmp;
                            }

                            if (x1 >= t) {
                                if (abs(evalCubic(x1, pa, pb, pc, pd)) <= epsilon) {
                                    float tc = x1;
                                    if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                        minT = tc;
                                        normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                    }
                                }
                            }

                            if (x2 >= t) {
                                if (abs(evalCubic(x2, pa, pb, pc, pd)) <= epsilon) {
                                    float tc = x2;
                                    if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                        minT = tc;
                                        normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                    }
                                }
                            }

                            if (x2 >= t && evalCubic(x1, pa, pb, pc, pd) * evalCubic(x2, pa, pb, pc, pd) <= 0.0) {
                                float tc = (evalCubic(x2, pa, pb, pc, pd) * x1 - evalCubic(x1, pa, pb, pc, pd) * x2) / (evalCubic(x2, pa, pb, pc, pd) - evalCubic(x1, pa, pb, pc, pd));
                                float tp = -1000.0;

                                for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                    float gt = evalCubic(tc, pa, pb, pc, pd);
                                    float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                    tp = tc;
                                    tc -= gt / gt_deriv;
                                }

                                if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                    minT = tc;
                                    normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                }
                            }

                            if (x2 <= t + 4.0 && evalCubic(x2, pa, pb, pc, pd) * evalCubic(t + 4.0, pa, pb, pc, pd) <= 0.0) {
                                float tc = (evalCubic(t + 4.0, pa, pb, pc, pd) * x2 - evalCubic(x2, pa, pb, pc, pd) * (t + 4.0)) / (evalCubic(t + 4.0, pa, pb, pc, pd) - evalCubic(x2, pa, pb, pc, pd));
                                float tp = -1000.0;

                                for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                    float gt = evalCubic(tc, pa, pb, pc, pd);
                                    float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                    tp = tc;
                                    tc -= gt / gt_deriv;
                                }

                                if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                    minT = tc;
                                    normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                }
                            }

                            if (x1 >= t && evalCubic(x1, pa, pb, pc, pd) * evalCubic(t - 4.0, pa, pb, pc, pd) <= 0.0) {
                                float tc = (evalCubic(x1, pa, pb, pc, pd) * (t - 4.0) - evalCubic(t - 4.0, pa, pb, pc, pd) * x1) / (evalCubic(x1, pa, pb, pc, pd) - evalCubic(t - 4.0, pa, pb, pc, pd));
                                float tp = -1000.0;

                                for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                    float gt = evalCubic(tc, pa, pb, pc, pd);
                                    float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                    tp = tc;
                                    tc -= gt / gt_deriv;
                                }

                                if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                    minT = tc;
                                    normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                }
                            }
                        } else {
                            if (evalCubic(t + 4.0, pa, pb, pc, pd) * evalCubic(t - 4.0, pa, pb, pc, pd) <= 0.0) {
                                float tc = (evalCubic(t + 4.0, pa, pb, pc, pd) * (t - 4.0) - evalCubic(t - 4.0, pa, pb, pc, pd) * (t + 4.0)) / (evalCubic(t + 4.0, pa, pb, pc, pd) - evalCubic(t - 4.0, pa, pb, pc, pd));
                                float tp = -1000.0;

                                for(int q = 0; q < 1000 && abs(tc-tp) >= 0.0001; q++) {
                                    float gt = evalCubic(tc, pa, pb, pc, pd);
                                    float gt_deriv = evalQuadratic(tc, qa, qb, qc);
                                    tp = tc;
                                    tc -= gt / gt_deriv;
                                }

                                if ((minT < 0.0 || tc < minT) && tc >= t && insideBox(r.origin + tc * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                                    minT = tc;
                                    normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                                }
                            }
                        }
#else
                        vec4 position = clamp(r.origin + r.direction * t, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax);
                        vec4 direction = normalize(r.direction);
                        float overlen = 1.0 / length(r.direction);

                        float d = getNodeDistance(position, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                        t += d * overlen;
                        uint count = 0;
                        while (abs(d) > minDist && abs(d) < maxDist && count < 1000 && insideBox(position, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                            position += direction * d;
                            d = getNodeDistance(position, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                            t += d * overlen;
                            count++;
                        }

                        if (abs(d) < maxDist && count < 1000 && insideBox(position, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax)) {
                            if (minT < 0.0 || t < minT) {
                                minT = t;
                                normal = getNodeNormal(r.origin + minT * r.direction, octreeNodes[index + offset].boxMin, octreeNodes[index + offset].boxMax, octreeNodes[index + offset].values);
                            }
                        }
#endif
#endif
                    }
                    offset = octreeNodes[index + offset].escape;
                } else {
                    offset = octreeNodes[index + offset].offset;
                }
            } else {
                offset = octreeNodes[index + offset].escape;
            }
        }
    }

    if (minT < 0.0) {
        return noHit();
    }

    return isHit(minT, ray, normalize(inverse(octrees[octree].inverseMatrix) * normal), vec2(0.0, 0.0), octrees[octree].material, false);
}

Hit raycast(Ray ray) {
    Hit h = noHit();

    for (int i = 0; i < primitiveCount; i++) {
        Hit tmp = noHit();
        if (primitives[i].type == 0) {
            tmp = hitPlane(primitives[i].data, ray, primitives[i].material);
        } else if (primitives[i].type == 1) {
            tmp = hitSphere(primitives[i].data, ray, primitives[i].material);
        } else if (primitives[i].type == 2) {
            tmp = hitCube(primitives[i].data, ray, primitives[i].material);
        }

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    for (uint i = 0; i < meshCount; i++) {
        Hit tmp = hitMesh(i, ray);

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    for (uint i = 0; i < gridCount; i++) {
        Hit tmp = hitGrid(i, ray);

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    for (uint i = 0; i < octreeCount; i++) {
        Hit tmp = hitOctree(i, ray);

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    return h;
}

vec4 skyColor(vec4 direction) {
        float m = 0.0;
        if (abs(direction.x) > m) {
            m = abs(direction.x);
        }
        if (abs(direction.y) > m) {
            m = abs(direction.y);
        }
        if (abs(direction.z) > m) {
            m = abs(direction.z);
        }
        return (vec4(direction.xyz / m, 1.0) + 1.0) * 0.5;
}

vec4 getLightColor(Hit hit) {
    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < lightCount; i++) {
        if (abs(lights[i].position.w) < epsilon) {
            if (hit.receivesShadows) {
                Ray ray;
                ray.origin = hit.point;
                ray.direction = lights[i].position;
                Hit h = raycast(ray);
                if (h.t < epsilon) {
                    color += lights[i].color * clamp(dot(hit.normal, normalize(lights[i].position)), 0.0, 1.0);
                }
            } else {
                color += lights[i].color * clamp(dot(hit.normal, normalize(lights[i].position)), 0.0, 1.0);
            }
        } else {
            vec4 lp = lights[i].position / lights[i].position.w;
            if (hit.receivesShadows) {
                Ray ray;
                ray.origin = hit.point;
                ray.direction = lp - hit.point;
                Hit h = raycast(ray);
                if (h.t < epsilon || h.t - 1.0 > epsilon) {
                    color += lights[i].color * clamp(dot(hit.normal, normalize(ray.direction)) / dot(ray.direction, ray.direction), 0.0, 1.0);
                }
            } else {
                color += lights[i].color * clamp(dot(hit.normal, normalize(lp - hit.point)) / dot(lp - hit.point, lp - hit.point), 0.0, 1.0);
            }
        }
    }
    return vec4(color.xyz, 1.0);
}

vec4 raytrace() {
    Ray ray = screenToRay();

    Hit h = raycast(ray);

    if (h.t > epsilon) {
        return (h.normal + 1.0) * 0.5;
        uint hitCount = 1;
        vec4 color = h.material.color * getLightColor(h);

        while (h.material.reflective > epsilon && hitCount < maxHitCount) {
            float refl = h.material.reflective;
            hitCount++;
            ray.origin = h.point;
            ray.direction = reflect(ray.direction, h.normal);
            h = raycast(ray);
            if (h.t > epsilon) {
                color = h.material.color * refl * getLightColor(h) + color * (1.0 - refl);
            } else {
                color = skyColor(ray.direction) * refl + color * (1.0 - refl);
                break;
            }
        }

        return color;
    } else {
        return skyColor(ray.direction);
    }
}

void main() {
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), raytrace());
}