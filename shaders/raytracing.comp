#version 450

const float epsilon = 0.00000001;
const uint maxHitCount = 5;

layout (binding = 0) uniform ParameterUBO {
    ivec2 screenSize;
    mat4 view;
    mat4 proj;
} ubo;

layout (binding = 1, rgba8) uniform writeonly image2D outputImage;

struct Material {
    vec4 color;
    float reflective;
    float refractiv; // not used
};

struct Primitive {
    vec4 data;
    uint type;
    Material material;
};

layout (std430, binding = 2) readonly buffer PrimitivesSSBO {
    uint primitiveCount;
    Primitive primitives[ ];
};

layout (std430, binding = 3) readonly buffer VertexSSBO {
    vec4 vertices[ ];
};

layout (std430, binding = 4) readonly buffer IndexSSBO {
    uint indices[ ];
};

struct Mesh {
    uint begin;
    Material material;
};

layout (std430, binding = 5) readonly buffer MeshSSBO {
    uint meshCount;
    Mesh meshes[ ];
};

layout (std430, binding = 6) readonly buffer TriangleSSBO {
    uint triangles[ ];
};

struct BVH {
    uint index;
    uint escape;
    uint left;
    uint right;
    vec4 AABBmin;
    vec4 AABBmax;
};

layout (std430, binding = 7) readonly buffer BVHSSBO {
    BVH bvhs[ ];
};

struct Light {
    vec4 position;
    vec4 color;
};

layout (std430, binding = 8) readonly buffer LightSSBO {
    uint lightCount;
    Light lights[ ];
};

struct Ray {
    vec4 origin;
    vec4 direction;
};

struct Hit {
    float t;
    vec4 point;
    vec4 normal;
    vec2 uv;
    Material material;
};

Hit noHit() {
    Hit h;
    h.t = -1.0;
    return h;
}

Hit isHit(float t, Ray ray, vec4 normal, vec2 uv, Material material) {
    Hit h;
    h.t = t;
    h.point = ray.origin + ray.direction * t * 0.9999;
    h.normal = normal,
    h.uv = uv;
    h.material = material;
    return h;
}

Hit hitPlane(vec4 plane, Ray ray, Material material) {
    float tmp = dot(plane, ray.direction);

    if (abs(tmp) < epsilon) {
        return noHit();
    }

    float t = -dot(plane, ray.origin) / tmp;

    if (t > epsilon) {
        vec4 normal = normalize(vec4(plane.xyz, 0.0));

        if (dot(normal, ray.direction) > epsilon) {
            // return noHit();
            normal = -normal;
        }

        return isHit(t, ray, normal, vec2(0.0, 0.0), material);
    }

    return noHit();
}

Hit hitSphere(vec4 sphere, Ray ray, Material material) {
    vec4 l = vec4(sphere.xyz, 1.0) - ray.origin;
    float tca = dot(l, normalize(ray.direction));
    if (tca <= epsilon) {
        return noHit();
    }
    float d2 = dot(l, l) - tca * tca;
    if (d2 > sphere.w * sphere.w) {
        return noHit();
    }
    float thc = sqrt(sphere.w * sphere.w - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;

    if (t0 > t1) {
        float tmp = t1;
        t1 = t0;
        t0 = t1;
    }

    if (t0 <= epsilon) {
        t0 = t1;
        if (t0 <= epsilon) {
            return noHit();
        }
    }

    t0 = t0 / length(ray.direction);

    vec4 normal = normalize(ray.origin + ray.direction * t0 - vec4(sphere.xyz, 1.0));

    return isHit(t0, ray, normal, vec2(0.0, 0.0), material);
}

Hit hitPolygon(uint triangle, Ray ray, Material material) {
    vec4 p1 = vertices[indices[triangle + 0]];
    vec4 p2 = vertices[indices[triangle + 1]];
    vec4 p3 = vertices[indices[triangle + 2]];

    vec4 e1 = p2 - p1;
    vec4 e2 = p3 - p1;
    vec4 crs = vec4(cross(ray.direction.xyz, e2.xyz), 0.0);

    float det = dot(e1, crs);

    if (abs(det) < epsilon) {
        return noHit();
    }

    float inv_det = 1.0 / det;
    vec4 s = ray.origin - p1;
    float u = inv_det * dot(s, crs);

    if ((u < -epsilon) || (u - 1.0 > epsilon)) {
        return noHit();
    }

    vec4 scrse1 = vec4(cross(s.xyz, e1.xyz), 0.0);
    float v = inv_det * dot(ray.direction, scrse1);

    if ((v < -epsilon) || (u + v - 1.0 > epsilon)) {
        return noHit();
    }

    float t = inv_det * dot(e2, scrse1);

    if (t > epsilon) {
        vec4 normal = normalize(vec4(cross(e1.xyz, e2.xyz), 0.0));
        if (dot(normal, ray.direction) > epsilon) {
            return noHit();
            // normal = -normal;
        }
        return isHit(t, ray, normal, vec2(u, v), material);
    }

    return noHit();
}

float hitAABB(uint index, Ray ray) {
    const int NUMDIM = 3;
    int RIGHT = 0;
    int LEFT = 1;
    int MIDDLE = 2;

    bool inside = true;
    int quadrant[NUMDIM];
    float candidatePlane[NUMDIM];

    vec4 _min = bvhs[index].AABBmin;
    vec4 _max = bvhs[index].AABBmax;
    
    for (int i = 0; i < NUMDIM; i++) {
        if (ray.origin[i] < _min[i]) {
            quadrant[i] = LEFT;
            candidatePlane[i] = _min[i];
            inside = false;
        } else if (ray.origin[i] > _max[i]) {
            quadrant[i] = RIGHT;
            candidatePlane[i] = _max[i];
            inside = false;
        } else {
            quadrant[i] = MIDDLE;
        }
    }

    if (inside) {
        return epsilon * 2;
    }
    
    vec4 maxT;

    for (int i = 0; i < NUMDIM; i++) {
        if (quadrant[i] != MIDDLE && abs(ray.direction[i]) >= epsilon) {
            maxT[i] = (candidatePlane[i] - ray.origin[i]) / ray.direction[i];
        } else {
            maxT[i] = -1.0f;
        }
    }

    int whichPlane = 0;

    for (int i = 1; i < NUMDIM; i++) {
        if (maxT[whichPlane] < maxT[i]) {
            whichPlane = i;
        }
    }

    if (maxT[whichPlane] < epsilon) {
        return -1.0;
    }

    for (int i = 0; i < NUMDIM; i++) {
        if (whichPlane != i) {
            float coord = ray.origin[i] + maxT[whichPlane] * ray.direction[i];
            if (coord < _min[i] || coord > _max[i]) {
                return -1.0;
            }
        }
    }

    return maxT[whichPlane];
}

Ray screenToRay() {
    vec2 sc = 2.0 * (vec2(gl_GlobalInvocationID.xy) - vec2(0.5, 0.5)) / vec2(ubo.screenSize.xy) - 1.0;
    sc = -sc;

    vec4 pos = ubo.view * ubo.proj * vec4(sc, 0.0, 1.0);
    pos /= pos.w;

    pos = normalize(pos - ubo.view * vec4(0.0, 0.0, 0.0, 1.0));

    Ray r;
    r.origin = ubo.view * vec4(0.0, 0.0, 0.0, 1.0);
    r.direction = pos;

    return r;
}

Hit hitMesh(uint mesh, Ray ray) {
    Hit h = noHit();

    uint i = meshes[mesh].begin + 1;

    //uint count = 0;

    while (i != 0) {
        float tmin = hitAABB(i - 1, ray);
        //count++;
        if (tmin > epsilon && (h.t <= epsilon || h.t > tmin)) {
            if (bvhs[i - 1].left == 0) {
                for (uint j = bvhs[i - 1].index; j < bvhs[i].index; j++) {
                    Hit tmp = hitPolygon(triangles[j], ray, meshes[mesh].material);

                    if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
                        h = tmp;
                    }
                }

                i = bvhs[i - 1].escape;
            } else {
                i = bvhs[i - 1].left;
            }
        } else {
            i = bvhs[i - 1].escape;
        }
    }
    // h.material.color += vec4((1.0 - h.material.color).xyz * count * 0.01, 0.0);

    return h;
}

Hit raycast(Ray ray) {
    Hit h = noHit();

    for (int i = 0; i < primitiveCount; i++) {
        Hit tmp = noHit();
        if (primitives[i].type == 0) {
            tmp = hitPlane(primitives[i].data, ray, primitives[i].material);
        } else if (primitives[i].type == 1) {
            tmp = hitSphere(primitives[i].data, ray, primitives[i].material);
        }

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    for (uint i = 0; i < meshCount; i++) {
        Hit tmp = hitMesh(i, ray);

        if (tmp.t > epsilon && (h.t <= epsilon || h.t > tmp.t)) {
            h = tmp;
        }
    }

    return h;
}

vec4 skyColor(vec4 direction) {
        float m = 0.0;
        if (abs(direction.x) > m) {
            m = abs(direction.x);
        }
        if (abs(direction.y) > m) {
            m = abs(direction.y);
        }
        if (abs(direction.z) > m) {
            m = abs(direction.z);
        }
        return (vec4(direction.xyz / m, 1.0) + 1.0) * 0.5;
}

vec4 getLightColor(vec4 point, vec4 normal) {
    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
    for (uint i = 0; i < lightCount; i++) {
        if (abs(lights[i].position.w) < epsilon) {
            Ray ray;
            ray.origin = point;
            ray.direction = lights[i].position;
            Hit h = raycast(ray);
            if (h.t < epsilon) {
                color += lights[i].color * clamp(dot(normal, normalize(lights[i].position)), 0.0, 1.0);
            }
        } else {
            vec4 lp = lights[i].position / lights[i].position.w;
            Ray ray;
            ray.origin = point;
            ray.direction = lp - point;
            Hit h = raycast(ray);
            if (h.t < epsilon || h.t - 1.0 > epsilon) {
                color += lights[i].color * clamp(dot(normal, normalize(ray.direction)) / dot(ray.direction, ray.direction), 0.0, 1.0);
            }
        }
    }
    return vec4(color.xyz, 1.0);
}

vec4 raytrace() {
    Ray ray = screenToRay();

    Hit h = raycast(ray);

    if (h.t > epsilon) {
        //return h.material.color;
        uint hitCount = 1;
        vec4 color = h.material.color * getLightColor(h.point, h.normal);

        while (h.material.reflective > epsilon && hitCount < maxHitCount) {
            float refl = h.material.reflective;
            hitCount++;
            ray.origin = h.point;
            ray.direction = reflect(ray.direction, h.normal);
            h = raycast(ray);
            if (h.t > epsilon) {
                color = h.material.color * refl * getLightColor(h.point, h.normal) + color * (1.0 - refl);
            } else {
                color = skyColor(ray.direction) * refl + color * (1.0 - refl);
                break;
            }
        }

        return color;
    } else {
        return skyColor(ray.direction);
    }
}

void main() {
    imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), raytrace());
}